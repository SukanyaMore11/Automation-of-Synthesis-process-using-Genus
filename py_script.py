import os
import numpy as np
import pandas as pd
import csv
import matplotlib.pyplot as plt
import datetime
import shutil
import re
import subprocess
from tracemalloc import start

os.getcwd() #checking current directory

#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
#To automate the synthesis of design and find the MAX clk_frequency possible for each design
#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#Define a function to synthesize the design with specified clk_period and return the obtained slack
def frequency_optimizer(clk_period, design):
    slack = 0
    tcl_script = "./Scripts/{0}/script_{1}.tcl".format(design, design)
    sdc_script = "./SDC/{0}/{1}.sdc".format(design, design)
    timing_report = "./Synthesis/{}/timing.txt".format(design)
    #Open the SDC file and change the CLK period to clk_period
    with open(sdc_script, 'r') as f: 
        lines = f.readlines()
        # Loop through the list and check if the line matches the pattern you want to edit
        for i, line in enumerate(lines):
            if 'create_clock' in line:
                updated_line = lines[i].split()
                updated_line[7] = "{}".format(clk_period/2)+"}" #Changing shape
                updated_line[4] = "{}".format(clk_period) #Changing CLK_period
                updated_line = " ".join(updated_line)
                # Replace the line with the new line
                lines[i] = updated_line + "\n"
        
        # Rewrite the lines in the SDC file
    with open(sdc_script, 'w') as f:
        f.writelines(lines)

    #Removing previous log and cmd files
    file_names = ["./genus.cmd", "./genus.log", "./flex"]
    for file_name in file_names:
        if os.path.exists(file_name):
            os.remove(file_name)
            print("Deleted existed file")
        
    
    #synthesize the tcl_script
    os.system("csh -c 'source ~/toolRC_PD; genus -legacy_ui -files {}'".format(tcl_script)) 

    #Now, open the timing.txt file generated by genus, to obtain the slack
    with open(timing_report, 'r+') as f: 
        # Real all the lines of the file
        lines = f.read()
        sp = lines.split("\n") #split all the lines
        for l in sp: 
            if "slack" in l:
                slack = l.split()[3]
                #check if slack is UNCONSTRAINED
                if(slack == "UNCONSTRAINED"):
                    return -1 #error code = -1
                else:
                    slack = int(slack[:-2])
                    print(slack)
    
    return slack

#We'll binary search for the optimal Clock_period for which total_slack = 0 ps
def max_clk_freq(design, start_period, end_period, convergence_value):
    start = start_period; end = end_period
    slack = 'uninitialized'
    clk_freqs = ['NA']
    while(start<=end):
        mid = (start+end)/2
        slack = frequency_optimizer(mid,design)
        clk_freqs.append([mid,slack])
        if(slack==convergence_value or slack == -1):
            return clk_freqs
        elif(slack<convergence_value):
            start = mid
        else:
            end = mid

    return -1

#Parameters to configure for finding max clk_frequency
start_clk_period_guess = 0 #ns
end_clk_period_guess = 2 #ns
# clk_period = 2.0 #ns
designs = ["FIFO", "Processor", "Convolution", "Counter"]

#Run a loop to find max clk_frequency for each design
for des in designs:
    print(max_clk_freq(des,start_clk_period_guess,end_clk_period_guess,0))

# print(max_clk_freq(designs[0],start_clk_period_guess,end_clk_period_guess,0))

#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
# Collecting data from reports and Creating CSV file
#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#Declaring all list for collecting appropriate data from the Genus generate reports
#For power
memory_power = list()
register_power = list()
latch_power = list()
logic_power = list()
bbox_power = list()
clock_power = list()
pad_power = list()
pm_power = list()
total_power = list()
#For Area
total_area = list()
#For Timing
critical_path_delay = list()
slack = list()
start_point = list()
end_point = list()

def power_report(design):
    file = "./Synthesis/{0}/power.txt".format(design)
    with open(file, 'r') as f:
        lines = f.readlines()
        
        for l in lines:
            if "memory" in l:
                power = float(l.split()[4])
                memory_power.append(power)
            if "register" in l:
                power = float(l.split()[4])
                register_power.append(power)
            if "latch" in l:
                power = float(l.split()[4])
                latch_power.append(power)
            if "logic" in l:
                power = float(l.split()[4])
                logic_power.append(power)
            if "bbox" in l:
                power = float(l.split()[4])
                bbox_power.append(power)
            if "clock" in l:
                power = float(l.split()[4])
                clock_power.append(power)
            if "pad" in l:
                power = float(l.split()[4])
                pad_power.append(power)
            if "pm" in l:
                power = float(l.split()[4])
                pm_power.append(power)
            if "Subtotal" in l:
                power = float(l.split()[4])
                total_power.append(power)
        

    return 0

def area_report(design):
    file = "./Synthesis/{0}/area.txt".format(design)
    with open(file, 'r') as f:
        lines = f.readlines()
        area = 0
        for l in lines:
            if "wl0" in l:
                area = area + float(l.split()[-3]) #Note that, we're indexing from backwards, as some lines in area.txt does not have "module" mentioned.
        #Since in area.txt, there could be multiple instances and area is specified for each instance,
        #we directly sum up all such areas in area.txt for given design and report the total_area.
        total_area.append(area)

    return 0

def timing_report(design):
    file = "./Synthesis/{0}/timing.txt".format(design)
    with open(file, 'r') as f:
        lines = f.readlines()
        for l in lines:
            if "capture" in l:
                var =  float(l.split()[-2])
                critical_path_delay.append(var)
            if "slack" in l:
                var =  float(l.split()[-1][:-2])
                slack.append(var)
            if "Start-point" in l:
                var =  l.split()[-1]
                start_point.append(var)
            if "End-point" in l:
                var =  l.split()[-1]
                end_point.append(var)

    return 0

#creating lists for all the designs using above functions
for des in designs:
    power_report(des)
    area_report(des)
    timing_report(des)

#Creating DataFrame
# print(memory_power, register_power, latch_power, logic_power, bbox_power, clock_power, pad_power, pm_power,total_power,total_area,critical_path_delay,slack,start_point,end_point, sep = "\n")
max_clk_frequency = [round((1/i)*1000,2) for i in critical_path_delay]
dictionary_to_store_data = {'Design': designs,"max_clk_frequency(GHz)":max_clk_frequency,"critical_path_delay(ps)":critical_path_delay,"slack(ps)":slack,"start_point":start_point,"end_point":end_point,'total_area(um^2)': total_area,'total_power(w)': total_power,'memory_power(w)': memory_power, 'register_power(w)':register_power, 'latch_power(w)':latch_power, 'logic_power(w)':logic_power,'bbox_power(w)':bbox_power,'clock_power(w)':clock_power, 'pad_power(w)':pad_power,'pm_power(w)':pm_power}

df = pd.DataFrame(dictionary_to_store_data)

#Create CSV file
df.to_csv('output.csv')
